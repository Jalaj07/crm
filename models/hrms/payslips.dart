// lib/models/payslips.dart

import 'package:hive/hive.dart'; // Import Hive
import '../../constants/payslips_app_constants.dart';

part 'payslips.g.dart'; // This line will be generated by build_runner

@HiveType(typeId: 1) // Unique typeId for PayslipItem (e.g., 1)
class PayslipItem {
  @HiveField(0)
  final String description;

  @HiveField(1)
  final double amount;

  PayslipItem({required this.description, required this.amount});

  // fromJson remains the same, useful for initial data loading or API data
  factory PayslipItem.fromJson(Map<String, dynamic> json) {
    final amount = (json['amount'] as num?)?.toDouble() ?? 0.0;
    return PayslipItem(
      description: json['description'] as String? ?? 'N/A',
      amount: amount,
    );
  }

  // toJson might be useful if you ever send this to a backend
  Map<String, dynamic> toJson() => {
    'description': description,
    'amount': amount,
  };
}

@HiveType(typeId: 0) // Unique typeId for Payslip (e.g., 0)
class Payslip extends HiveObject {
  // Extend HiveObject
  @HiveField(0)
  final String id;

  @HiveField(1)
  final String name;

  @HiveField(2)
  final String employeeName;

  @HiveField(3)
  final String employeeId;

  @HiveField(4)
  final String dateFrom;

  @HiveField(5)
  final String dateTo;

  @HiveField(6)
  final String status;

  @HiveField(7)
  final double grossEarnings;

  @HiveField(8)
  final double totalDeductions;

  @HiveField(9)
  final double netSalary;

  @HiveField(10)
  // Hive needs to know the type of items in the list
  // The PayslipItemAdapter (which we'll generate) handles this.
  late List<PayslipItem> earnings; // Changed to 'late' and non-final for HiveObject

  @HiveField(11)
  late List<PayslipItem> deductions; // Changed to 'late' and non-final for HiveObject

  // --- Constructor ---
  // Constructor for creating new Payslip instances or for Hive to re-hydrate
  Payslip({
    required this.id,
    required this.name,
    required this.employeeName,
    required this.employeeId,
    required this.dateFrom,
    required this.dateTo,
    required this.status,
    required this.grossEarnings,
    required this.totalDeductions,
    required this.netSalary,
    required this.earnings, // Make earnings and deductions required here
    required this.deductions,
  });

  // Getter using the constant remains the same
  bool get isProcessed => status == kStatusDone;

  // fromJson factory is still very useful for converting mock data or API data
  factory Payslip.fromJson(Map<String, dynamic> json) {
    List<PayslipItem> parseItems(List<dynamic>? itemsJson) {
      if (itemsJson == null) return [];
      return itemsJson
          .whereType<Map<String, dynamic>>()
          .map((item) => PayslipItem.fromJson(item))
          .toList();
    }

    // Note: For grossEarnings, totalDeductions, netSalary ensure they are correctly
    // populated for non-processed payslips (e.g. 0.0 instead of null) if your Hive model fields are non-nullable doubles.
    // Your current Payslip.fromJson handles nulls by converting them to 0.0 which is fine.
    return Payslip(
      id:
          json['id'] as String? ??
          DateTime.now().microsecondsSinceEpoch
              .toString(), // Default ID if null
      name: json['name'] as String? ?? 'Untitled Payslip',
      employeeName: json['employeeName'] as String? ?? 'N/A',
      employeeId: json['employeeId'] as String? ?? 'N/A',
      dateFrom: json['dateFrom'] as String? ?? 'N/A',
      dateTo: json['dateTo'] as String? ?? 'N/A',
      status: json['status'] as String? ?? 'Unknown',
      grossEarnings: (json['grossEarnings'] as num?)?.toDouble() ?? 0.0,
      totalDeductions: (json['totalDeductions'] as num?)?.toDouble() ?? 0.0,
      netSalary: (json['netSalary'] as num?)?.toDouble() ?? 0.0,
      earnings: parseItems(json['earnings'] as List<dynamic>?),
      deductions: parseItems(json['deductions'] as List<dynamic>?),
    );
  }

  // toJson might be useful for sending data or debugging
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'employeeName': employeeName,
    'employeeId': employeeId,
    'dateFrom': dateFrom,
    'dateTo': dateTo,
    'status': status,
    'grossEarnings': grossEarnings,
    'totalDeductions': totalDeductions,
    'netSalary': netSalary,
    'earnings': earnings.map((e) => e.toJson()).toList(),
    'deductions': deductions.map((d) => d.toJson()).toList(),
  };
}
